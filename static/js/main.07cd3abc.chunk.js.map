{"version":3,"sources":["store/model/index.ts","utils/snake.ts","store/model/game.ts","utils/constants.ts","types.ts","store/index.ts","store/hooks.ts","components/Tile.tsx","components/Column.tsx","components/Grid.tsx","utils/positions.ts","utils/apples.ts","pages/Game.tsx","Root.tsx","serviceWorker.ts","index.tsx"],"names":["DIRECTION","generateSnake","length","snake","i","push","x","y","game","dots","setSnake","action","state","apples","setApples","model","store","createStore","createTypedHooks","useStoreActions","useStoreState","useStoreDispatch","Tile","styled","div","props","isHead","isActive","isApple","tiles","Array","Column","indexColumn","map","_","indexRow","R","rows","Grid","GridContainer","tileWidth","index","MAP_POSITION","RIGHT","LEFT","UP","DOWN","moveToDirection","direction","pos","VERTICAL_DIRECTIONS","HORIZONTAL_DIRECTIONS","isOpossiteForVertical","isOpossiteForHorizontal","getRandomNumber","minimum","maximum","min","Math","ceil","max","floor","random","isPositionEqual","p1","p2","generateApples","count","keys$","fromEvent","document","pipe","pluck","MAP_DIRECTION","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","length$","BehaviorSubject","nextDirection","prevDirection","newDirection","snakeLength$","scan","step","snakeLength","share","direction$","key","filter","startWith","distinctUntilChanged","snake$","switchMap","interval","withLatestFrom","lastDirection","move","head","tail","lastPosition","newPosition","apples$","eaten","find","a","score$","score","scene$","combineLatest","game$","of","animationFrameScheduler","fps$","scene","takeWhile","isGameOver","isOverGrid","some","p","Game","useEffect","sub","subscribe","unsubscribe","Root","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.07cd3abc.chunk.js","sourcesContent":["import { game, GameModel } from './game';\n\nexport enum DIRECTION {\n  RIGHT = 'RIGHT',\n  LEFT = 'LEFT',\n  UP = 'UP',\n  DOWN = 'DOWN',\n}\n\nexport interface StoreModel {\n  game: GameModel;\n}\n\nexport const model: StoreModel = {\n  game,\n};\n","import { Position } from '../types';\n\nexport const generateSnake = (length: number) => {\n  let snake: Position[] = [];\n\n  for (let i = length - 1; i >= 0; i--) {\n    snake.push({ x: i, y: 0 });\n  }\n\n  return snake;\n};\n","import { action, Action } from 'easy-peasy';\nimport { Position } from '../../types';\nimport { generateSnake } from '../../utils/snake';\nimport { SNAKE_LENGTH } from '../../utils/constants';\n\nexport interface GameModel {\n  dots: Position[];\n  snake?: Position[];\n  setSnake: Action<GameModel, Position[]>;\n  apples: Position[];\n  setApples: Action<GameModel, Position[]>;\n}\n\nexport const game: GameModel = {\n  snake: generateSnake(SNAKE_LENGTH),\n  dots: [{ x: 1, y: 1 }],\n  setSnake: action((state, snake) => {\n    state.snake = snake;\n  }),\n  apples: [],\n  setApples: action((state, apples) => {\n    state.apples = apples;\n  }),\n};\n","export const GRID_WIDTH = 30;\nexport const GRID_HEIGHT = 30;\nexport const SNAKE_LENGTH = 10;\nexport const APPLE_COUNT = 2;\n","export enum DIRECTION {\n  RIGHT = 'RIGHT',\n  LEFT = 'LEFT',\n  UP = 'UP',\n  DOWN = 'DOWN',\n}\nexport type Position = { x: number; y: number };\n","import { createStore } from 'easy-peasy';\nimport { model } from './model';\n\nexport const store = createStore(model);\n","import { createTypedHooks } from 'easy-peasy';\nimport { StoreModel } from './model';\n\nconst { useStoreActions, useStoreState, useStoreDispatch } =\n  createTypedHooks<StoreModel>();\n\nexport { useStoreActions, useStoreState, useStoreDispatch };\n","import styled from '@emotion/styled';\n\ntype Props = {\n  isActive: boolean;\n  isHead: boolean;\n  isApple: boolean;\n};\nexport const Tile = styled.div<Props>`\n  width: 10px;\n  height: 10px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  margin: 1px;\n  background-color: ${(props) =>\n    props.isHead\n      ? 'green'\n      : props.isActive\n      ? 'red'\n      : props.isApple\n      ? 'blue'\n      : 'transparent'};\n`;\n","import React from 'react';\nimport * as R from 'ramda';\nimport { GRID_WIDTH } from '../utils/constants';\nimport { useStoreState } from '../store/hooks';\nimport { Tile } from './Tile';\n\nconst tiles = [...Array(GRID_WIDTH)];\ntype Props = {\n  indexColumn: number;\n};\n\nexport const Column: React.FC<Props> = ({ indexColumn }) => {\n  const snake = useStoreState((store) => store.game.snake);\n  const apples = useStoreState((store) => store.game.apples);\n\n  if (!snake) {\n    return null;\n  }\n\n  return (\n    <div>\n      {tiles.map((_, indexRow) => {\n        return (\n          <Tile\n            key={indexRow}\n            isActive={R.includes({ x: indexColumn, y: indexRow }, snake)}\n            isApple={R.includes({ x: indexColumn, y: indexRow }, apples)}\n            isHead={snake[0].x === indexColumn && snake[0].y === indexRow}\n          />\n        );\n      })}\n    </div>\n  );\n};\n","import React from 'react';\nimport styled from '@emotion/styled';\nimport { GRID_HEIGHT, GRID_WIDTH } from '../utils/constants';\nimport { Column } from './Column';\n\ntype Props = {\n  tileWidth: number;\n};\n\nconst rows = [...Array(GRID_HEIGHT)];\nexport const Grid: React.FC = () => (\n  <GridContainer tileWidth={10}>\n    {rows.map((_, index) => (\n      <Column key={index} indexColumn={index}></Column>\n    ))}\n  </GridContainer>\n);\n\nconst GridContainer = styled.div<Props>`\n  display: flex;\n  max-width: ${(props) => (props.tileWidth + 2 + 2) * GRID_WIDTH}px;\n  max-height: ${(props) => (props.tileWidth + 2 + 2) * GRID_HEIGHT}px;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n`;\n","import * as R from 'ramda';\nimport { Position, DIRECTION } from '../types';\nimport { GRID_HEIGHT, GRID_WIDTH } from './constants';\n\nexport const positionZero: Position = { x: 0, y: 0 };\nexport const moveToDown = ({ x, y }: Position): Position => ({ x, y: y + 1 });\nexport const moveToUp = ({ x, y }: Position): Position => ({ x, y: y - 1 });\nexport const moveToLeft = ({ x, y }: Position): Position => ({ x: x - 1, y });\nexport const moveToRight = ({ x, y }: Position): Position => ({ x: x + 1, y });\n\nconst MAP_POSITION: Record<DIRECTION, (pos: Position) => Position> = {\n  [DIRECTION.RIGHT]: moveToRight,\n  [DIRECTION.LEFT]: moveToLeft,\n  [DIRECTION.UP]: moveToUp,\n  [DIRECTION.DOWN]: moveToDown,\n};\n\nexport const moveToDirection = ({\n  direction,\n  pos,\n}: {\n  direction: DIRECTION;\n  pos: Position;\n}): Position => MAP_POSITION[direction](pos);\n\nconst VERTICAL_DIRECTIONS = [DIRECTION.UP, DIRECTION.DOWN];\nconst HORIZONTAL_DIRECTIONS = [DIRECTION.LEFT, DIRECTION.RIGHT];\nexport const isOpossiteForVertical = R.compose(\n  R.equals(0),\n  R.length,\n  R.without(HORIZONTAL_DIRECTIONS),\n);\nexport const isOpossiteForHorizontal = R.compose(\n  R.equals(0),\n  R.length,\n  R.without(VERTICAL_DIRECTIONS),\n);\n\nexport const isOpposite = (direction: DIRECTION, newDirection: DIRECTION) =>\n  R.either(\n    isOpossiteForVertical,\n    isOpossiteForHorizontal,\n  )([direction, newDirection]);\n\nconst getRandomNumber = (minimum: number, maximum: number) => {\n  const min = Math.ceil(minimum);\n  const max = Math.floor(maximum);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nexport const getRandomPosition = (): Position => ({\n  x: getRandomNumber(0, GRID_WIDTH),\n  y: getRandomNumber(0, GRID_HEIGHT),\n});\n\nexport const isPositionEqual = (p1: Position, p2: Position) =>\n  p1.x === p2.x && p1.y === p2.y;\n","import { getRandomPosition } from './positions';\n\nexport const generateApples = (count: number) => {\n  const apples = [];\n\n  for (let i = 0; i < count; i++) {\n    apples.push(getRandomPosition());\n  }\n\n  return apples;\n};\n","import React, { useEffect } from 'react';\nimport {\n  interval,\n  of,\n  fromEvent,\n  BehaviorSubject,\n  animationFrameScheduler,\n  combineLatest,\n} from 'rxjs';\nimport {\n  pluck,\n  scan,\n  map,\n  switchMap,\n  withLatestFrom,\n  filter,\n  startWith,\n  distinctUntilChanged,\n  share,\n  takeWhile,\n  // skip,\n  // tap,\n} from 'rxjs/operators';\nimport { useStoreActions } from '../store/hooks';\nimport { DIRECTION } from '../store/model';\nimport { Grid } from '../components/Grid';\nimport {\n  moveToDirection,\n  isOpposite,\n  isPositionEqual,\n} from '../utils/positions';\nimport { Position } from '../types';\nimport {\n  APPLE_COUNT,\n  GRID_HEIGHT,\n  GRID_WIDTH,\n  SNAKE_LENGTH,\n} from '../utils/constants';\nimport { generateSnake } from '../utils/snake';\nimport { generateApples } from '../utils/apples';\nimport * as R from 'ramda';\n\nconst keys$ = fromEvent<KeyboardEvent>(document, 'keydown').pipe(pluck('code'));\nconst MAP_DIRECTION: Record<string, DIRECTION> = {\n  ArrowUp: DIRECTION.UP,\n  ArrowDown: DIRECTION.DOWN,\n  ArrowLeft: DIRECTION.LEFT,\n  ArrowRight: DIRECTION.RIGHT,\n};\nconst length$ = new BehaviorSubject<number>(SNAKE_LENGTH);\n\nconst nextDirection = (prevDirection: DIRECTION, nextDirection: DIRECTION) =>\n  isOpposite(prevDirection, nextDirection) ? prevDirection : nextDirection;\n\nconst snakeLength$ = length$.pipe(\n  scan((step, snakeLength) => snakeLength + step),\n  share(),\n);\nconst direction$ = keys$.pipe(\n  map((key) => MAP_DIRECTION[key]),\n  filter((direction) => !!direction),\n  startWith(DIRECTION.RIGHT),\n  distinctUntilChanged(),\n);\n\nconst gameSpeed$ = new BehaviorSubject(200);\n\n// TEST for speed up\n// let increment = 1;\n// setInterval(() => {\n//   increment += 1;\n//   gameSpeed$.next(200 / increment);\n// }, 3000);\n\nconst move$ = gameSpeed$.pipe(\n  switchMap((i) =>\n    interval(i).pipe(\n      withLatestFrom(direction$, (_, direction) => ({\n        direction,\n      })),\n      scan(\n        (lastDirection, { direction }): DIRECTION =>\n          nextDirection(lastDirection, direction),\n        DIRECTION.RIGHT,\n      ),\n    ),\n  ),\n);\n\nconst moveSnake = (\n  snake: Position[],\n  { move, snakeLength }: { move: DIRECTION; snakeLength: number },\n): Position[] => {\n  const [head, ...tail] = snake;\n  let lastPosition = head;\n\n  return [\n    moveToDirection({ direction: move, pos: head }),\n    ...tail.map<Position>((pos) => {\n      const newPosition = { ...lastPosition };\n      lastPosition = pos;\n      return newPosition;\n    }),\n    ...(snakeLength > snake.length ? [snake[snake.length - 1]] : []),\n  ];\n};\n\nconst snake$ = move$.pipe(\n  withLatestFrom(snakeLength$, (move, snakeLength) => ({\n    move,\n    snakeLength,\n  })),\n  scan(moveSnake, generateSnake(SNAKE_LENGTH)),\n  share(),\n);\n\nconst eat = (apples: Position[], snake: Position[]) => {\n  const [head] = snake;\n  const eaten = apples.find((a) => isPositionEqual(a, head));\n  if (eaten) {\n    return [...R.without([eaten], apples), ...generateApples(1)];\n  }\n  return apples;\n};\nconst apples$ = snake$.pipe(\n  scan(eat, generateApples(APPLE_COUNT)),\n  distinctUntilChanged(),\n  share(),\n);\n\n// const appleEaten$ = apples$\n//   .pipe(\n//     skip(1),\n//     tap(() => length$.next(POINTS_PER_APPLE)),\n//   )\n//   .subscribe();\n\nconst POINTS_PER_APPLE = 1;\nconst score$ = snakeLength$.pipe(\n  startWith(0),\n  scan((score, _) => score + POINTS_PER_APPLE),\n);\nexport type Scene = {\n  snake: Position[];\n  apples: Position[];\n  score: number;\n};\n\nconst scene$ = combineLatest([snake$, apples$, score$]).pipe<Scene>(\n  map(([snake, apples, score]) => ({ snake, apples, score })),\n);\n\nconst FPS = 60;\nexport const game$ = of('Start Game').pipe(\n  map(() => interval(1000 / FPS, animationFrameScheduler)),\n  switchMap((fps$) => fps$.pipe(withLatestFrom(scene$, (_, scene) => scene))),\n  takeWhile((scene) => !isGameOver(scene)),\n);\n\nconst isOverGrid = ({ x, y }: Position) =>\n  x >= GRID_WIDTH || x < 0 || y >= GRID_HEIGHT || y < 0;\n\nconst isGameOver = (scene: Scene) => {\n  const { snake } = scene;\n  const [head, ...tail] = snake;\n  return isOverGrid(head) || tail.some((p) => isPositionEqual(p, head));\n};\n\nexport const Game: React.FC = () => {\n  const { setSnake, setApples } = useStoreActions((store) => ({\n    setSnake: store.game.setSnake,\n    setApples: store.game.setApples,\n  }));\n\n  useEffect(() => {\n    const sub = game$.subscribe((scene) => {\n      setSnake(scene.snake);\n      setApples(scene.apples);\n    });\n    return () => sub.unsubscribe();\n  });\n\n  return (\n    <>\n      <h1>Snake</h1>\n      <Grid />\n    </>\n  );\n};\n","import React from 'react';\nimport { StoreProvider } from 'easy-peasy';\nimport { store } from './store';\nimport { Game } from './pages/Game';\n\nconst Root: React.FC = () => (\n  <StoreProvider store={store}>\n    <Game />\n  </StoreProvider>\n);\n\nexport default Root;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href,\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Root from './Root';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Root />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}